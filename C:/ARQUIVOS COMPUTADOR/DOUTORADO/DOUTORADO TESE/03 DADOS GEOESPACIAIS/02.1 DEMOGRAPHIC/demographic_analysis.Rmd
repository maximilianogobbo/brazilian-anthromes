---
title: "Populated anthromes: from exploratory analysis of demographic data to mapping"
author: "Maximiliano Gobbo"
date: '2023-05-24'
output:
  html_document:
    number_sections: yes
  pdf_document: default
  word_document: default
editor_options: 
  markdown: 
    wrap: sentence
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE, paged.print=TRUE}
library(dplyr)  
library(gapminder)
library(geodata)
library(ggmap)
library(ggnewscale)
library(ggplot2)
library(ggspatial)
library(gridExtra)
library(GSODR)
library(leaflet)
library(magrittr)
library(mapdata)
library(osmdata)
library(ows4R)
library(pander)
library(raster)
library(rgdal)
library(sf)      
library(spData)
library(terra)   
library(tidycensus)
library(tidyverse)
library(tigris)
library(tmap)
```

# Introduction

::: {style="text-align: justify"}
According to Biggs et al. (2021), one of the essential steps for building socio-ecological models involves the survey of attributes that should make up their analytical structure. According to these authors, it is essential that each of the attributes be identified, recognized and analyzed, in order to recognize the data profile and its possible application, whether in descriptive terms or in terms of information mapping.

From this perspective, Ellis (2020) presented that population attributes, mainly demographic density, associated with anthromes are fundamental for modeling anthropogenic biomes, both on a global and local scale. Guided by these guidelines regarding demographic aspects linked to anthromes, in this work we carried out an exploratory analysis of census data produced by the Brazilian Institute of Geography and Statistics (IBGE).

The exploratory analysis aimed to identify the attributes that made up the data from the census operation carried out by IBGE in 2010 (IBGE, 2013a). Furthermore, we tried to recognize special characteristics that would allow the integration of the tabular data provided by this institution, intending to expand the data set for modeling anthromes locally.

In addition, we strive to evaluate the possibility of plotting this data, that is, of spatially distributing census information in local mappings. This operation was performed in the R® software, using the investigative guidelines presented by Lovelace et al. (2019) and Anderson (2021) for exploratory analysis and creation of mappings and plots of geographic information. These authors presented a critical-analytical format in their works, demonstrating the logic involved in achieving the objectives just presented for this work.

Throughout the exploratory analysis, we presented detailed summaries of the functions used and which were extracted from the two works just discussed. Through this research, we carried out a survey of characteristics of census data, in vector and raster formats, which would allow their use in structuring the decision tree for classifying anthromes locally. To this end, we emphasize that this was an essential step in building the modeling of anthropogenic biomes in R® language. In it, we recognized attributes of the demographic data that aligned with those identified by Gauthier (2021) and Ellis, Beusen and Goldewijk (2020) as fundamental for mapping anthromes in R®.

We highlight that the format of this manuscript does not follow conventional textual standards, where "Introduction", "Methodology/Materials and Methods", "Results and Discussion" and "Conclusions" are separately detailed. Here, we report using a logical programming format, that is, we first present what was carried out in the R software (Methodology), then the R code (Methodology and Results) and, as the results are generated by the computer program, they are discussed below (Discussion). Therefore, this is the format adopted in this manuscript, in order to facilitate analytical understanding and concatenate the analyzes carried out.  

# Demographic Data: from loading to mapping

## Exploratory Analysis of Demographic Data

In the first stage of the exploratory analysis of demographic data, the tabular files provided by the Brazilian Institute of Geography and Statistics (IBGE) were downloaded from the institution's digital platform. According to IBGE, the lowest level of data disaggregation is the micro data from the 2010 Census, that is, this data contains information for each of the cities investigated by IBGE during the demographic census. These data show the distribution of the municipal population in urban and rural areas and also in different urban systems, such as municipal headquarters or outside the municipal headquarters. The web page where this data is available is:

<https://www.ibge.gov.br/estatisticas/sociais/populacao/9662-censo-demografico-2010.html?=&t=microdados>.

We point out that we used data referring to the State of São Paulo (Brazil) as an experimental model for mapping anthromes locally, as this Federation Unit (UF) encompasses different territorial typologies (land uses and covers) and has significant representation in the economy , in national politics and management, as well as symbolic distribution and population size.

The files downloaded from the IBGE platform were included in a folder associated with the work (directory) for later application in the R® software. This folder contains the guidance documentation provided by the Brazilian Institute, the micro data and tables referring to the population of the State of São Paulo recorded in the 2010 Census. The tabular data are in the ".xls" extension (Microsoft Access 365) for import into R®.

We point out that some adjustments to the content of the tables were necessary, as they prevented the files from being read correctly in the software. Therefore, the tabular files were opened in *Microsoft Access 365* to remove titles and additional information, such as subtitles, captions and bibliographic references, which appeared in the original data. Thus, in the edited data only the names of the attributes remained (first line of each column) and the census data for each attribute necessary for analysis.

Furthermore, we emphasize that the numeric tabular data contained spacing between units and a hyphen (-) in null values, characteristics that prevented the data from being read as numeric values, being interpreted by R as "characters". Therefore, we edited the tables made available by IBGE, removing spaces and replacing hyphens with zeros (0) in the sets analyzed in this work. Please note that these edits were made in *Microsoft Excel 365*.

The operations performed in the *Access 365* and *Excel 365* programs are not reported throughout the text. However, the edited tabular files, in ".xls" format, were made available as complementary files for this work and are available on the EcoMetrologia Project's GitHub <https://github.com/maximilianogobbo/landuseplanning.git>\> and can be accessed remotely. Furthermore, all documents that make up the demographic data portfolio, including the R and Rmarkdown scripts, were saved in a single directory, in order to facilitate and streamline the operation, manipulation and analysis of data in the software. The getwd (_) function shows the referenced working directory, the virtual location where all the documents for this investigation are located:

```{r echo=FALSE}
getwd() 
```

Of all the documents downloaded from the IBGE platform, only 3 of them were used in the first phase of the exploratory analysis, as only these contained information about: the geographic location of the municipalities in the State of São Paulo, the population in each of the subdivisions established in the census, the area and/or demographic density of each municipality.

Below, the loading of each of the tables in R® is presented separately using the read_excel () function. For this function to operate, the file name and directory where the tables were saved were indicated, as illustrated in Script 1 below.

Furthermore, in this preliminary phase, two other functions were used subsequent to loading. The names() function, to identify the name of the data set attributes (first line of tabular data), and the summary() function, which offers a synthesis of the data analyzed by it, whether in qualitative terms (characters) or in quantitative terms (numerical and statistical).

The first table loaded into the software was "population01.xls", using the read_excel () function. Sequentially, we transformed the table into an object (data frame), which was named population01. Using the names() function, we check the names of the attributes in this data set. Subsequently, we use the summary () function to obtain a qualitative and quantitative synthesis of the population01 data frame. Script 1 (code) illustrates this preliminary procedure in R® language.

Script: Loading and Preliminary Analysis of population01

```{r include=FALSE}
library(readxl)
population01 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/population01.xls")

names(population01)[names(population01) == "municipio"] = "city" #rename the colun municipio for city

population01
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
names(population01) 

summary(population01)
```

Source: the authors (2023). Caption: preliminary analysis of the population data set using the functions: names (_) and summary (_) in the R software.

The preliminary analysis of data from **population01** revealed some important aspects about the set. The first to be scored involves the names () function that indicates the name of the attributes that make up the data frame. These attributes refer to the typologies of census sectors (land use) to indicate the number of inhabitants registered in each of them for each of the municipalities in São Paulo.

As seen in the summary () results, there are 645 lines (length) that represent the municipalities of the State. Each of the lines offers the number of inhabitants registered in each of the territorial typologies associated with the city, which is indicated in the first line of the data set.

Another aspect to be highlighted in the results presented by this function is the attribute **Código da Unidade Geográfica**, despite being defined by values (numbers), it is a numerical descriptor, that is, a sequence of numbers assigned to determine the area of reference. This descriptor code is understood, in software engineering and database modeling, as identifying attributes, which are not repeated throughout the data set and are exclusively attributed to an entity, which in the case of the population01 data frame are the cities paulistas.

That said, we carried out the same analytical procedure with the "population02.xls" table in the directory, from which the **population02** data frame was created and which is described in Script 2.

Script: Loading and Preliminary Analysis of population02

```{r include=FALSE}
population02 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/population02.xls")

names(population02)[names(population02) == "municipio"] = "city" 

population02
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
names(population02) 

summary(population02) 
```

Source: the authors (2023). Caption: preliminary analysis of the population data set using the functions: names (_) and summary (_) in the R software. 

We observed, through the results obtained by the names() function, that the population02 set has some attributes with the same name and others different from those present in the **population01** data frame. We highlight the attributes "demographic density" and "total area", which are information about the number of individuals in a given area and the total area of the census sector, respectively. Again, the attribute **Código da Unidade Geográfica** is interpreted as a numeric attribute, incurring the same problem identified previously for **population01**.

Next, we performed the same procedure with the file "population03.xls", which gave rise to the data frame **population03**, as shown in Script 3.

Script: Loading and Preliminary Analysis of population03

```{r include=FALSE}
population03 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/population03.xls")

names(population03)[names(population03) == "municipio"] = "city" 

population03
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
names(population03) 

summary(population03) 
```

Source: the authors (2023). Caption: preliminary analysis of the population data set using the functions: names (_) and summary (_) in the R software. 

In Script 3, in addition to presenting the results of the two analytical functions, we also report the first 10 lines of the data frame **population03**, presented right after loading the data using the read_excel () function.

We observed that in the set **population03** there are other numerical attributes, namely: *Relative Total (%) (in Portuguese, Total Relativa)* and *Relative municipal headquarters (%) (in Portuguese, Na sede municipal Relativa)*. These attributes, however, represent statistical proportions of the population in each of the cities in São Paulo, and are not exactly attributed to population dimensions, such as concentration or demographic density.

Furthermore, we reiterate that the identifying attribute **Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)** is also part of this data frame, which is the only identifier present in the three sets analyzed up to this point. However, in the three sets there is no direct definition of information that spatializes geographic information, such as longitude, latitude and altitude of points or polygons referring to census sectors.

Even identifying these obstacles that have only been addressed, we expanded the preliminary analysis with two other functions. Firstly, the class() function to recognize the structural format of the three sets. Sequentially, the dim() function that gives the number of rows and columns of the data sets. Script 4 below demonstrates the results obtained.

Script: Application of the functions class (_) and dim (_) in the Preliminary Analysis

```{r echo=TRUE, message=FALSE, warning=FALSE}
class(population01)
class (population02)
class(population03)

dim(population01)
dim(population02)
dim(population03)
```

Source: the authors (2023). Caption: Preliminary analysis of the data sets using the functions: class (_) and dim (_) in the R software. 

We observed, in the results generated by the class () function, that the three data sets (population01, population02 and population03) are of the data frame type, that is, they are structured following the distribution of information in rows and columns (tabular, from the English acronym, tbl). In the columns of the data frames, information that characterizes the municipalities of the State of São Paulo is reported, that is, the answer for each of the attributes identified in the first line of the data frames. On the other hand, the dim() function reported that the data frame **population01** is composed of 645 lines and 10 columns, while **population02** is structured in 645 lines and 8 columns and **population03** in 645 lines and 10 columns.

Given this information, we confirm that all lines in the **population01** data frame correspond to **population02** and **population03**, that is, all cities are present in the three data frames. However, we found that the number of columns differs between the data sets, a fact that we had observed when applying the names () and summary () functions. This occurs because there are attributes that are present in one that do not integrate the others and vice-versa, thus changing the number of columns in each of them.

Returning to the attribute **Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)**, present in the three data frames, we carried out a specific analysis to identify how the information for each city is read by the software.
We use the summary () function again and filter the column of this attribute using square brackets [], which are used to specify the attribute, as we demonstrated in Script 5.

Script: Analysis of the "Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)" attribute

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(population01["Código da Unidade Geográfica"])
summary(population02["Código da Unidade Geográfica"])
summary(population03["Código da Unidade Geográfica"])
```

Source: the authors (2023). Caption: analysis of the “Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)” attribute using the summary (_) function and selecting the attribute using square brackets [].

In line with what we presented previously, the summary () function returned statistical information about this attribute. Above it can be seen that the minimum (min.), first quartile (1st Qu.), mean, mean, third quartile (3rd Qu.) and maximum (max.) values of the data set are presented. Therefore, we confirm that the interpretation of this identifying attribute by the software is not done as an area identifier code, but as a numerical value. This prevents the direct plotting of data in mapping, requiring other geographic information to do so.

From this perspective, we carried out a new search on the IBGE platform to find the files referring to the identifying attribute **Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)**. The files related to this attribute were downloaded and indexed in the same working directory as the exploratory analysis and are available at the following link, accessible remotely. 

<https://www.ibge.gov.br/geociencias/organizacao-do-territorio/estrutura-territorial/27385-localidades.html?=&t=acesso-ao-produto>.

In this search, we captured the shape files made available by IBGE, which contain the set of geographic information (code geometry: longitude, latitude and altitude) that represent the **Geographic Unit Code (in Portuguese, Código da Unidade Geográficas)** of the 3 data frames (population01, population02 and population03 ). With these shape files, we envision connecting the census data from the three sets to the spatial structures of their locations (census sector).

To this end, the first step was to load the raster file into R using the shape file () function, which is used to read raster data in the software. The data set loaded by this function was named **br_locations_2010**, converting it into an object for exploratory analysis. After loading the raster data, we carried out the same analytical procedures demonstrated so far. We use the names () function to identify the names of the attributes that make up the **br_locations_2010** data set. On the other hand, the summary() function was used to recognize the qualitative and quantitative structure of this object (Script 7).

Script: Preliminary analysis of br_locations_2010

```{r include=FALSE}
br_locations_2010 <- shapefile("br_locations_2010.shp")

names(br_locations_2010)[names(br_locations_2010) == "NM_MUNICIP"] = "city" 
names(br_locations_2010)[names(br_locations_2010) == "NM_UF"] = "state" 
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
names(br_locations_2010)
summary(br_locations_2010)
crs(br_locations_2010)
```

Source: the authors (2023).

The results show that the set **br_locations_2010** is composed of 21,886 lines and 22 attributes described in columns. The geometry type of the data set is in the format of points and is structured in XY dimensions, having integrated values of *xmin*, *ymin*, *xmax* and *ymax* within the structure. Furthermore, the data set has the geographic reference system (CRS) based on the EPSG (acronym for *European Petroleum Survey Group*) "SIRGAS 2000" format.

We also highlight that the 22 attributes that make up the data set are: *ID*, *CD_GEOCODI*, *TIPO*, *CD_GEOCODB*, *NM_BAIRRO*, *CD_GEOCODS*, *NM_SUBDIST*, *CD_GEOCODD*, *NM_DISTRIT*, *CD_GEOCODM*,*city*, *NM_MICRO*, *NM_MESO*, *state*, *CD_NIVEL* ,*CD_CATEGOR*, *NM_CATEGOR*, *NM_LOCALID*, *LONG*, *LAT*, *ALT*  and *GMRotation*. Of these, we confirmed the presence of attributes associated with the geographic positioning of information, such as *longitude (LONG)*, *latitude (LAT)*, *altitude (ALT)* and *geometry*. Furthermore, we have the presence of territorial subdivisions described in the **br_locations_2010** data set, as we verified that, sequentially, the tabular format of the data starts from the lowest level of aggregation, being neighborhood (NM_BAIRRO), and reaching States . These results, therefore, provided us with clues to understand the structure of the data and to identify relevant attributes for data mining in R®.

In order to test the spatialization of the information contained in the **br_locations_2010** data set, we applied the plot () function in the analytical sequence to visualize the distribution of points described by the data frame, as can be seen in Figure 1.

Figure: Plotting of data from br_locations_2010

```{r echo=FALSE}
plot(br_locations_2010) 
```

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/Figure_01.png", res = 300, width = 2400, height = 2400)
plot(br_locations_2010)
dev.off
```

Source: the authors (2023). Caption: figure produced through the function plot (_), using the data set br_locations_2010. Outline in red representing the Brazilian territorial polygon, inserted to demonstrate the distribution of points.

The plot illustrates each of the 21,886 points that make up the data set, using the geographic coordinates of each of the Brazilian locations to carry it out. The blank spaces, where there are no points marked on the plot, represent areas where there was no population decline (areas without human occupation/demographic voids) and/or where the populations sampled in these areas were considered within census sectors close to their area establishment, as suggested in the reference document for carrying out the Brazilian census operation (IBGE, 2013).

Based on the names of the attributes of **br_locations_2010**, we verified that the column *NM_UF*, referring to the *Name of the Federation Unit*, allows the filtering of data related to the State of São Paulo, making it possible to cut the data set to meet the experimental area of this research. Furthermore, we verified that this data frame is composed of geographically distributed points, given the presence of the attributes *longitude* (LONG), *latitude* (LAT) and *altitude* (ALT). Furthermore, there are structural characteristics in the data frame that help in the spatialization of geographic information, which are presented in Script 7 by the information *coords.x1* and *coords.x2.*

In order to individualize the data from the State of São Paulo, we returned to the *Microsoft Access 365* program (initial format of the data set made available by IBGE) to filter the data from **localities_br**. We filtered the data set using the *NM_UF* attribute, which protects the *Names of the Federation Units*, selecting only the lines that had *São Paulo* as response data (character inserted in the *NM_UF* column line). This selected data was copied to an *Excel 365* spreadsheet and saved in the ".xls" extension with the name **localsp.xls**. We reiterate that both the original file (*Access 365*) and the produced file (*Excel 365*) are in the GitHub digital collection and can be accessed remotely.

After producing the **localsp.xls** file, we return to R, where we look for the file in the work directory to be loaded into the software using the read_excel () function. Along with loading, we create the **localsp** object, as illustrated in the Script. After loading the data, we took the opportunity to rename some attributes that were part of the data set through the names () function, namely: a) *NM_MUNICIPIO*, replaced by *city*; b) *NM_UF*, by *state*; c) *LONG* for *longitude*; d) *LAT* for *latitude*; e) *ALT* for *altitude*. Finally, we confirm the creation of the dataset and the changes to the attribute names, actions that are described in the following script.

Script: Loading data and creating the localsp object.

```{r include=FALSE}
localsp <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/localsp.xls")

names(localsp)[names(localsp) == "NM_MUNICIPIO"] = "city" 
names(localsp)[names(localsp) == "NM_UF"] = "state" 
names(localsp)[names(localsp) == "LONG"] = "longitude" 
names(localsp)[names(localsp) == "LAT"] = "latitude" 
names(localsp)[names(localsp) == "ALT"] = "altitude"
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
localsp
```

Source: the authors (2023). Caption: loading data from localsp.xls and creating the localsp object. In the script, the format of the data set and the attributes (variables) that constitute it are highlighted.  

The object creation check allowed us to extract some relevant information about the **localsp** set. The results in Script 10 indicated that the object is structured in a data frame model (free translation from English, *tibble*), which is composed of 2,142 lines (from English, *rows*) and 21 variables (from English, *variables *) distributed in columns, which depict the attributes of this data set. The names of the attributes (variables) were highlighted in the Script above and we point out that they are the same attributes that make up localities_br, except for the geometry attribute (GEOMETRY) which was not subject to filtering in Access 365 and, therefore, is not part of the **localsp set **.

Following the same functions previously used in the preliminary analysis (Table 10), we explored the **localsp** data set, aiming to identify relevant characteristics for the exploratory analysis, as demonstrated in Script 11.

Script 11: Preliminary analysis of localsp

```{r echo=TRUE, message=FALSE, warning=FALSE}
names(localsp)
summary(localsp)
dim(localsp)
class(localsp)
```

Source: the authors (2023). Caption: Preliminary analysis of the localsp set. The script presents the results obtained by applying the names (), dim (), class () and summary () function.  

Using the names() function, we confirm the names of the attributes associated with the data set, that is, the names in the first line of the object. We also found that **localsp** is composed of different spatial characteristics, such as longitude, latitude and altitude, and identifying attributes, such as *ID* and *CD_GEOCODIGO*. We should highlight that the *ID* attribute, despite referring to the identity of certain geographic information, is a variant code in each line of the data set, as can be seen in the results generated by Script 10. We note that the same municipality has different codes *IDs* and that they refer to different typologies of land use or urban agglomerations, which is confirmed through the attributes *CD_NIVEL* and *CD_CATEGORIA* (numeric codes that refer to the different typologies) and * NM_CATEGORY* (nomeclatura variables for specifying the typology).

On the other hand, when paying attention to the *CD_GEOCODE* attribute, we observed numerical repetition for the different profiles of land use and coverage and typologies of human settlements, that is, the same identifying code was repeated for the municipalities. According to the technical documentation of the 2010 Census (IBGE, 2013), it was found that *CD_GEOCODIGO* refers to the geographical area identifier code, which is established by IBGE to refer to a certain polygon (census sector) in the territory Brazilian, as we had previously discussed.

Additionally, the dim () function showed that the set is composed of 2142 lines and 21 columns, which describe data attributes. Furthermore, the class () function revealed that the **localsp** data presentation format is structured in the tabular model (from the acronym, *tbl*) and constitutes a data frame (*df*).

Additionally, the summary () function expanded the information about each of the attributes associated with the set. Through its application, different characteristics were summarized. For attributes that assumed the character profile (*character*), the function returned the number of lines in each column (*length*), the class of information in the column (*class* ) and the presentation model (*mode*). For information that was not characters, statistical results were returned for the numerical values associated with the attributes, such as: *minimum value, first and third quartile, mean, average* and *maximum*.

We point out that the statistical results, in the case of **localsp**, are not relevant for the exploratory analysis. However, these results demonstrate which attributes are interpreted by the software as numerical attributes. Thus, we identified that the attributes longitude, latitude and altitude have numerical data for each of the census sectors. This favors the use of this information for the spatialization of specific geographic information, as we identified in the sets **population01**, **population02** and **population03**.

Comparatively, we verified, through the results generated by the dim() function, that the population data frames (**population01**, **population02** and **population03**) are made up of 645 lines (Script 4), while * *localsp** is made up of 2,142 lines (Script 11). This substantial difference in the number of lines between the population groups and **localsp** reflects the fragmentation of population information, that is, in the **localsp** data frame there are subdivisions of the types of population clusters that make up the urban perimeter, as previously indicated about the codes **CD_NIVEL**, **CD_CATEGORIA** and **NM_CATEGORIA** that make up this set.

As we found in the 2010 Demographic Census documentation (IBGE, 2013a), the sampling points that make up the **localsp** data detail the territorial mesh in a more robust way, that is, they further divide the territorial portions, reaching the micro data of the Demographic census. On the other hand, in **population01**, **population02** and **population03** there is an agglomeration of this micro data given by municipalities, reducing the number of lines when compared to **localsp**. However, as observed in Scripts 1, 2 and 3, the typologies of population clusters are attributes that integrate the three population groups (population01/02/03). Therefore, through these indications about the components of the 4 sets (localsp and population01/02/03) we have the indication to proceed with the joining of these data frames. 

## Data Mining and Manipulation

Having indicated the relevant aspects about the four central sets of this exploratory analysis, we move on to mining the data that make up the sets for further connection between them. In the **localsp** dataset, we identified the presence of territorial subdivisions in the **NM_CATEGORIA** column, which reflected the typology of the census sector. The following Script reveals the names of the variables present in the column of this set attribute (**localsp**). According to the technical documentation of the 2010 Census (IBGE, 2013a), the categories in the micro data portray the profile of population clusters present in the national territory and, consequently, in the State of São Paulo. Thus, it is understood that these categories reveal how human groups are inserted into the territory, assuming a strong relationship with land use and land cover.

```{r echo=FALSE, message=FALSE, warning=FALSE}
names_localsp <- unique(localsp$NM_CATEGORIA)
names_localsp
```

Considering the categories, it was extracted from the IBGE documentation (2013a), that they are subdivided into two groups: urban and rural. Among the urban areas are: *cities, isolated urban areas (AUI) and towns*; while in rural areas there are: *nuclei, villages, hamlets, settlement projects and indigenous villages (traditional communities)*. Following the logic described by the Institute, we subdivided the **localsp** data set based on the **NM_CATEGORIA** attribute, generating data sets for each of the categories referring to the different typologies of census sectors and/or clusters population. The following script depicts the procedure for creating the sets: **sp_cities, sp_isolatedurbanareas, sp_urbanvillages, sp_traditionalcommunities, sp_ruralvillage, sp_ruralcore, sp_settlement and sp_settlementproject**; which was performed using the filter() function. 

Script: Subdivision of the **localsp** dataset based on the **NM_CATEGORY** attribute.

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Urban Groups
#creating the city group
sp_cities = localsp %>% filter(NM_CATEGORIA == "CIDADE")

#creating isolated urban areas group
sp_isolatedurbanareas = localsp %>% filter(NM_CATEGORIA == "AUI")

#creating the group of villages (urban)
sp_urbanvillages = localsp %>% filter(NM_CATEGORIA == "VILA")

#Rural Groups
#creating the group of indigenous villages
sp_traditionalcommunities = localsp %>% filter(NM_CATEGORIA == "ALDEIA INDÍGENA")

#creating the group of rural villages
sp_ruralvillage = localsp %>% filter(NM_CATEGORIA == "LUGAREJO")

#creating the rural core group
sp_ruralcore = localsp %>% filter(NM_CATEGORIA == "NÚCLEO")

#creating the settlement group (rural)
sp_settlement = localsp %>% filter(NM_CATEGORIA == "POVOADO")

#creating the settlement project group (rural)
sp_settlementproject = localsp %>% filter(NM_CATEGORIA == "PROJETO DE ASSENTAMENTO")
```

Source: the authors (2023). Caption: Script describing the separation of the localsp dataset into 8 categories, which describe the typologies of population clusters from the 2010 Census, separated into two groups: urban and rural.

After creating the different data sets, based on the population grouping categories, we plotted each of them, using the *longitude* and *latitude* columns (18 and 19 respectively) to evaluate the spatialization capacity of these data.

Figure: Plot of data from locals separated by categories of population clusters.

```{r echo=FALSE, message=FALSE, warning=FALSE}
#plot of data: sp_cities, sp_isolatedurbanareas, sp_urbanvillages, sp_traditionalcommunities, sp_ruralvillage, sp_ruralcore, sp_settlement e sp_settlementproject

par(mfrow=c(2,4))
plot(sp_cities[18:19])
plot(sp_isolatedurbanareas[18:19])
plot(sp_urbanvillages[18:19])
plot(sp_traditionalcommunities[18:19])
plot(sp_ruralvillage[18:19])
plot(sp_ruralcore[18:19])
plot(sp_settlement[18:19])
plot(sp_settlementproject[18:19])
```

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/Figure_categoriesofpopulation.png", res = 300, width = 2400, height = 1700)
par(mfrow=c(2,4))
plot(sp_cities[18:19])
plot(sp_isolatedurbanareas[18:19])
plot(sp_urbanvillages[18:19])
plot(sp_traditionalcommunities[18:19])
plot(sp_ruralvillage[18:19])
plot(sp_ruralcore[18:19])
plot(sp_settlement[18:19])
plot(sp_settlementproject[18:19])
dev.off
```

Source: the authors (2023). Caption: Figure generated from categorized data from localsp, where each of the graphs represents a category of population cluster. The number of points reflects the number of variables in the eight plotted sets.

When we turned to the population data sets (population01/02/03), we identified that the set **population01** was the one that most completely discriminated the different categories of population clusters. This confirmation occurred through the analysis of the attributes that made up the three sets, as illustrated in the following script, which uses the names() function for comparison.

Table: Comparison of attributes that make up population groups.

```{r include=FALSE}
nomes_pop01 <- names(population01)
nomes_pop02 <- names(population02)
nomes_pop03 <- names(population03)

num_max_linhas <- max(length(nomes_pop01), length(nomes_pop02), length(nomes_pop03))

set01 <- data.frame(set1 = nomes_pop01)
set02 <- data.frame(set2 = nomes_pop02)
set03 <- data.frame(set3 = nomes_pop03)

df_combinado <- data.frame(matrix(NA, nrow = num_max_linhas, ncol = 3))

df_combinado[1:length(nomes_pop01), 1] <- set01$set1
df_combinado[1:length(nomes_pop02), 2] <- set02$set2
df_combinado[1:length(nomes_pop03), 3] <- set03$set3

colnames(df_combinado) <- c("Population 01", "Population 02", "Population 03")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(df_combinado)
```

Source: the authors (2023). Legend: Table showing the attributes that make up the three population groups (population01, population02 and population03). The "NA" demonstrates that the population02 set has a smaller number of columns in its structure.

As seen in the results generated, we confirm that the set **population01** presents the breakdown of the categories of population clusters previously found in **localsp**, namely: *municipality, urbanized area, non-urbanized area, isolated urban area , rural area (except agglomeration), urban extension rural agglomeration, populated rural agglomeration, core rural agglomeration and other rare rural agglomerations*. Given this, we chose to focus on the set **population01** to advance the correlation of data, considering its synergy with **localsp** data (and its categories) and its completeness over the municipalities of São Paulo.

From this perspective, we fragmented **population01** data into 8 groups, following the data frame construction logic. In each of the 8 sets created, we kept the first and last columns, respectively "city" and "CD_GEOCODIGO", both of utmost importance for correlation with the data from **localsp**, as we treated previously. On the other hand, the other population01 columns were the variable objects for creating the 8 new sets, each integrating a new set.

Therefore, the following Script describes how the creation of isolated sets of demographic information were carried out according to the category (typology) of the population cluster. It is worth highlighting that for the partitioning and creation of the following 8 sets, we used as a reference the technical documentation of the 2010 Census (IBGE, 2013a), which explains which categories each of the attributes described in columns 2 to 9 of the set belong to * *population01** and which are also the categories present in **localsp** (NM_CATEGORIA).

Script: Partitioning population data01 according to population cluster categories.

```{r echo=TRUE, message=FALSE, warning=FALSE}
pop01_cities <- population01[,c(1,2,10)]
pop01_cities

pop01_isolatedurbanareas <- population01[,c(1,4,10)]
pop01_isolatedurbanareas

pop01_urbanvillages <- population01[,c(1,3,10)]
pop01_urbanvillages

pop01_traditionalcommunities <- population01[,c(1,5,10)]
pop01_traditionalcommunities

pop01_ruralvillage <- population01[,c(1,6,10)]
pop01_ruralvillage

pop01_ruralcore <- population01[,c(1,8,10)]
pop01_ruralcore

pop01_settlement <- population01[,c(1,7,10)]
pop01_settlement

pop01_settlementproject <- population01[,c(1,9,10)]
pop01_settlementproject
```

Source: the authors (2023). Caption: In the script, data from the population01 set is partitioned according to the category of the population cluster. Columns 2 to 9 of the population01 set are isolated and integrated with columns 1 (city) and 10 (CD_GEOCODIGO), structuring 8 new data sets, namely: *pop01_cities, pop01_isolatedurbanareas, pop01_urbanvillages, pop01_traditionalcommunities, pop01_ruralvillage, pop01_ruralcore, pop01_settlement and pop01_settlementproject*.

Comparing the 8 sets from **localsp** and the 8 from **population01**, we noticed that there is a divergence between them in the number of lines and it is necessary to make some notes on the following table. The first reflects that not all micro data categories (NM_CATEGORIES) are present in all municipalities in São Paulo and, therefore, do not correspond between the sets. On the other hand, it is noted that there are more than one point to describe a category, that is, there are more than one point identified for a given category, as is the case of isolated urban areas (985 lines).

Table: Comparison between the number of lines of the 8 sets formed from **population01** and the 8 derived from **localsp**

```{r include=FALSE}
coluna01 <- c((nrow(pop01_cities)),(nrow(pop01_isolatedurbanareas)), (nrow(pop01_urbanvillages)), (nrow(pop01_traditionalcommunities)),(nrow(pop01_ruralvillage)),(nrow(pop01_ruralcore)),(nrow(pop01_settlement)),(nrow(pop01_settlementproject)))
coluna01

coluna02 <- c((nrow(sp_cities)), (nrow(sp_isolatedurbanareas)), (nrow(sp_urbanvillages)), (nrow(sp_traditionalcommunities)), (nrow(sp_ruralvillage)), (nrow(sp_ruralcore)), (nrow(sp_settlement)), (nrow(sp_settlementproject)))
coluna02

datacompare <- data.frame("Data coming from population01" = coluna01, "Data coming from localsp" = coluna02)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
print(datacompare)
```

Source: the authors (2023). Legend: Table comparing the number of lines in the sets from **population01** (first column) and **localsp** (second column).

Despite the divergence between the number of lines, we emphasize that this does not invalidate data mining; on the contrary, this confirms the presence and/or absence of different categories in the territory of São Paulo and allows us to recognize the demography in each of the municipalities that make up the micro data.

## Data Joining

Having established the 8 sets from **localsp** and the 8 derived from **population01**, we set out to join these sets, as a way of spatializing the demographic data. Therefore, we are guided by data from **localsp**, to which we add the respective populations (number of people). As we highlighted previously, there is a numerical divergence between the data from the two sets (Table) and therefore we must consider two aspects.

The first protects row numbers equal to or less than 645, where there is a correspondence between Column 1 (data from **population01**) and Column 2 (data from **localsp**) of the Table. In this sense, when there is no point described for sampling (column 2), there is no population described for a given typology of census sector. On the other hand, when all lines in Column 2 correspond to Column 1, all sample points had their populations integrated.

In the second aspect, we portray the cases in which Column 2 has a number of points greater than 645 lines, extrapolating the number of lines present in Column 1, that is, not all geographic points coming from **localsp** have correspondence in * *population01**. The only case described and represented throughout data mining was that for isolated urban areas (AUI), portrayed in the set **sp_isolatedurbanareas**. According to the IBGE technical documentation (2023), isolated urban areas are "an area defined by law and separated from the district headquarters [*municipality*] by rural area or by another legal limit"; therefore, it is understood that the same municipality may have different AUIs integrated during the census sampling, as can be seen in Column 2 of the Table (line 2). However, as can be seen in Column 1 of the Table, the data is combined, that is, all isolated urban areas in the municipality have their populations depicted in a single line. To this end, for the sake of analysis, and already identifying a sampling limitation, we considered the total population of AUIs for each point, that is, the values for the same municipality (Column 1) are repeated for the points associated with the same municipality ( Column 2). This overestimation of data will be dealt with during data mapping by differentiating colors on the map and, jointly, in the legend referring to data from isolated urban areas.

That said, let's move on to data joining. Following the same logic just used, we divided the join into two moments, the first for the sets in Column 2 with points equal to or less than 645 lines and the second for the number of points greater than 645.

Script: Joining data from **population01** and **localsp**.

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Joining data from the Cities typology
cities <- sp_cities%>%left_join(pop01_cities)

#Joining data from the Urban Villages typology
urbanvillages <- sp_urbanvillages%>%inner_join(pop01_urbanvillages)

#Joining data from the Traditional Communities typology
traditionalcommunities <- sp_traditionalcommunities%>%inner_join(pop01_traditionalcommunities)

#Joining data from the Rural Village typology
ruralvillage <- sp_ruralvillage%>%inner_join(pop01_ruralvillage)

#Joining data from the Rural Core typology
ruralcore <- sp_ruralcore%>%inner_join(pop01_ruralcore)

#Joining data from the Rural Villages typology
ruralsettlement <- sp_settlement%>%inner_join(pop01_settlement)

#Joining data from the Settlement Projects typology
settlementproject <- sp_settlementproject%>%inner_join(pop01_settlementproject)

#Joining data from the Isolated Urban Areas typology
isolatedurbanareas <- sp_isolatedurbanareas%>%right_join(pop01_isolatedurbanareas)
isolatedurbanareas <- isolatedurbanareas[complete.cases(isolatedurbanareas$altitude, isolatedurbanareas$latitude),]
```

Source: the authors (2023). Caption: in the script, information from **population01** is associated with the locations of **localsp**, through the join() function and its variants.

According to the Script, we were able to connect the data from **population01** and **localsp**, adding the respective populations to the different census typologies. In this way, we structure new sets, where the population information and geolocations of each of the points structured for them are found, namely: *cities, urbanvillages, isolatedurbanareas, traditionalcommunities, ruralvillage, ruralcore, ruralsettlement* and *settlementproject*.

```{r include=FALSE}
names(cities)[names(cities) == "Área Urbanizada"] = "população"
names(urbanvillages)[names(urbanvillages) == "Área não Urbanizada"] = "população"
names(isolatedurbanareas)[names(isolatedurbanareas) == "Área Urbana Isolada"] = "população"
names(traditionalcommunities)[names(traditionalcommunities) == "Área Rural (Exceto Aglomerado)"] = "população"
names(ruralvillage)[names(ruralvillage) == "Aglomerado Rural de Extensão Urbana"] = "população"
names(ruralcore)[names(ruralcore) == "Aglomerado Rural Núcleo"] = "população"
names(ruralsettlement)[names(ruralsettlement) == "Aglomerado Rural Povoado"] = "população"
names(settlementproject)[names(settlementproject) == "Outros Aglomerados Rurais Raros"] = "população"
```

## Data plotting 

Once the data joining stage is complete, we move on to plotting this data. Firstly, we must highlight that the choice of colors for the plot followed the guidelines established by Ellis and Ramankutty (2008), where shades of red represent urban populations and their nuances; while rural populations are associated with earthy tones (orange and brown). Furthermore, we use shades of blue to distinguish traditional populations, taking into account their sociocultural uniqueness, both in terms of their relationship with nature and in relation to their relevance for the maintenance and preservation of the identity of these groups. The Table presents the tones used (RGB code) for each territorial typology described by the data.

It is worth highlighting here that, unlike what was proposed for anthromes, we consider the features identified by IBGE (2023) in the spatial continuum proposal. According to this document, we notice an expansion of concepts and, consequently, of urban-rural approaches, which proves to be extremely relevant for structuring public policies in the country. Therefore, the continuum project proposed by the Brazilian Institute expands the guidelines proposed by Ellis (2020) regarding anthromes and, therefore, we consider this as an improvement in the delineation of Brazilian anthromes.

We emphasize from the outset that the IBGE document, published in 2023, uses in its analytical structuring and modeling, to a large extent, data from the 2010 Demographic Census (IBGE, 2013), a fact that aligns our project with the technical-scientific developments of the Brazilian Institute and does not invalidate such data as a source for current scientific production. It is also worth considering that both the IBGE document (2023) and this research precede the publication of the complete data from the 2022 Demographic Census, that is, this limitation is present in both products, which must be updated after the publication of the data complete IBGE data. However, we reiterate, this does not invalidate the development of this work, as the codified structure is adaptable to different sources of information, as well as the subsequent update of data from the Brazilian Demographic Census, carried out in 2022.

That said, we return to the attributes *longitude* and *latitude* that are part of the data sets just produced. Since these two attributes are fundamental for spatialization in the plot and, subsequently, in the mapping of population information, they are the ones used to construct the plot of the data below. Therefore, we select these two pieces of information using the "$" operator in each of the sets. Additionally, we chose the format for plotting the points using the "pch" descriptor, using the number "15" to plot as squares filled in the same color, which was chosen using the "col" descriptor. As we said above, the colors vary according to the typology of the census sector (Table). Below is the Script that encodes the separation of data, its plotting and the respective coloring of each one.

Script: Plotting the 8 data sets separately.

```{r echo=FALSE, message=FALSE, warning=FALSE}
#plotting of the joined data - already with the coloring specified for each demographic typology

plot(cities$latitude, cities$longitude, pch=15, cex = cities$população/max(cities$população), col="#FF0000") 

plot(isolatedurbanareas$latitude, isolatedurbanareas$longitude, pch=15, cex = isolatedurbanareas$população/max(isolatedurbanareas$população),col="#FF4747")

plot(urbanvillages$latitude, urbanvillages$longitude, pch=15, cex = urbanvillages$população/max(urbanvillages$população), col="#F66969")

plot(ruralvillage$latitude, ruralvillage $longitude, pch=15, cex = ruralvillage$população/max(ruralvillage$população), col="#ED833B")
  
plot(ruralcore$latitude, ruralcore$longitude, pch=15, cex = ruralcore$população/max(ruralcore$população), col="#DF9B6D")

plot(ruralsettlement$latitude, ruralsettlement$longitude, pch=15, cex = ruralsettlement$população/max(ruralsettlement$população), col="#FFD966")
  
plot(settlementproject$latitude, settlementproject$longitude, pch=15, cex = settlementproject$população/max(settlementproject$população), col="#968551")

plot(traditionalcommunities$latitude, traditionalcommunities$longitude, pch=15, cex = traditionalcommunities$população/max(traditionalcommunities$população), col="#9CC2E5")

```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/cities.png", res = 300, width = 3600, height = 2400)
plot(cities$latitude, cities$longitude, pch=15, cex = cities$população/max(cities$população), col="#FF0000")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/isolatedurbanareas.png", res = 300, width = 3600, height = 2400)
plot(isolatedurbanareas$latitude, isolatedurbanareas$longitude, pch=15, cex = isolatedurbanareas$população/max(isolatedurbanareas$população),col="#FF4747")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/urbanvillages.png", res = 300, width = 3600, height = 2400)
plot(urbanvillages$latitude, urbanvillages$longitude, pch=15, cex = urbanvillages$população/max(urbanvillages$população), col="#F66969")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/ruralvillage.png", res = 300, width = 3600, height = 2400)
plot(ruralvillage $latitude, ruralvillage $longitude, pch=15, cex = ruralvillage$população/max(ruralvillage$população), col="#ED833B")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/ruralcore.png", res = 300, width = 3600, height = 2400)
plot(ruralcore$latitude, ruralcore$longitude, pch=15, cex = ruralcore$população/max(ruralcore$população), col="#DF9B6D")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/ruralsettlement.png", res = 300, width = 3600, height = 2400)
plot(ruralsettlement$latitude, ruralsettlement$longitude, pch=15, cex = ruralsettlement$população/max(ruralsettlement$população), col="#FFD966")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/settlementproject.png", res = 300, width = 3600, height = 2400)
plot(settlementproject$latitude, settlementproject$longitude, pch=15, cex = settlementproject$população/max(settlementproject$população), col="#968551")
dev.off
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/traditionalcommunities.png", res = 300, width = 3600, height = 2400)
plot(traditionalcommunities$latitude, traditionalcommunities$longitude, pch=15, cex = traditionalcommunities$população/max(traditionalcommunities$população), col="#9CC2E5")
dev.off
```

Source: the authors (2023). Legend: plot of population data from different territorial typologies with their respective colors.
As can be seen in the plots just produced, the data for each of the territorial typologies were spatialized according to the two geographic information (latitude and longitude). The "cex" descriptor defined for each municipality the size of the square plotted following the size of the reference population (attribute *population* of each data set). It is worth noting that we added a new column to the 8 data sets, which was named **category**; In this column, the territorial typologies were inserted in the data sets, so that we could plot the 8 sets in a single plot. Additionally, we created the **colors** set, which determines the colors for the unique plot of populated anthromes. The following script presents these processes.

Script: Coded structure for plotting the 8 data sets.

*cities, urbanvillages, isolatedurbanareas, traditionalcommunities, ruralvillage, ruralcore, ruralsettlement* and *settlementproject*

```{r message=FALSE, warning=FALSE, include=FALSE}
populated_anthromes <- rbind(transform(cities, categoria = "Cities"), transform(isolatedurbanareas, categoria = "Isolated Urban Areas"), transform(urbanvillages, categoria = "Urban Villages"), transform(ruralvillage, categoria = "Rural Village"), transform(ruralcore, categoria = "Rural Core"), transform(ruralsettlement, categoria = "Rural Settlement"), transform(settlementproject, categoria = "Settlement Project"), transform(traditionalcommunities, categoria = "Traditional Communities"))
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
colors <- c("Cities" = "#FF0000", "Isolated Urban Areas" = "#FF4747", "Urban Villages"= "#F66969", "Rural Village"= "#ED833B", "Rural Core"="#DF9B6D", "Rural Settlement"="#FFD966", "Settlement Project"="#968551", "Traditional Communities"="#9CC2E5")

legend_populatedanthromes <- data.frame(Categorias = unique(populated_anthromes$categoria), Cores = unique(colors))

legend_populatedanthromes
```

Source: the authors (2023). Legend: the script presents the coded structures for plotting the 8 data sets, which are guided by the *populated_anthromes* and *colors.* data sets

Once these operations were carried out, we proceeded to plot the data from the 8 sets simultaneously. We follow the color pattern established by the **colors** set and the respective typologies of the population sectors described by **category**. We reiterate that the spatialization of the data was based on *latitude* and *longitude* information.

Figure: Plot of data from the 8 sets of population anthromes.

```{r echo=FALSE, message=FALSE, warning=FALSE}
plot(populated_anthromes$longitude, populated_anthromes$latitude, xlab= "Longitude", ylab= "Latitude", pch=15, cex = 0.5, col = colors[populated_anthromes$categoria], main = "Populated Anthromes")
legend("topright", legend = legend_populatedanthromes$Categorias, pch = 15, col = legend_populatedanthromes$Cores, cex = 0.7, bty = "n")
```

Source: the authors (2023). Caption: plot of data referring to populated anthromes in the State of São Paulo, divided between the 8 categories created based on IBGE data.

The Figure reveals that the plotting of data from the 8 population groups (census typologies) occurred correctly, allowing the integration of the different typologies into a single figure. Furthermore, it is noted that the legend follows the coloring established for the different territorial categories. Therefore, through the figure, we can see the adequacy of the data distribution for territorial mapping, carried out in the analytical sequence. 

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/populatedanthromessp.png", res = 300, width = 3600, height = 2400)
plot(populated_anthromes$longitude, populated_anthromes$latitude, xlab= "Longitude", ylab= "Latitude", pch=15, cex= 0.5, col = colors[populated_anthromes$categoria], main = "Populated Anthromes")
legend("topright", legend = legend_populatedanthromes$Categorias, pch = 15, col = legend_populatedanthromes$Cores, cex = 0.7, bty = "n")
dev.off
```

## Static mapping of populated anthromes

After plotting the **populated_anthromes** data, we move on to the static mapping of this data set. The static mapping aimed to structure the distribution of points in the shape file of the municipalities (urban perimeters) of the State of São Paulo. To carry out this mapping, some adjustments to the sets were necessary, which are summarized below. The code for carrying out these actions was hidden in this document; however, it is found in the file available on GitHub associated with this work.

1. Organization and determination of the color categories used for each typology of populated anthromes, determining how colorimetric information and anthropogenic types should be combined.
2. Upload the shape file **sp_municipios.shp** made available by IBGE. This file refers only to municipalities in the State of São Paulo, therefore, only the polygons referring to cities in São Paulo appear on the generated map.
3. Creation of the shapefile set **cities_shape**, where the attributes *NM_MUNICIP* and *geometry* from the set **sp_municipios.shp** were selected, isolating them for the construction of the mapping of São Paulo cities.

We take the opportunity to justify the use of the shape file file as a means to construct the mapping. Our first option for mapping was to use the orbital images provided by *Google Earth*, using the *API Key* to integrate the mapping with the *Google LCC.* platform. However, during the construction of the mapping, we identified that the use of images provided by the company only occurs upon payment. Despite the technological advantages of using these *Earth* images in mapping, we chose not to use them, considering the cost of operation at this stage of the research and the free services already provided by the Brazilian Institute of Geography and Statistics, as we will demonstrate. by the shape file used in the mapping. To this end, we opted for IBGE files to maintain our technical-scientific alignment with free national data structures, allowing other researchers and users to access and build mappings such as the one presented below. 

```{r include=FALSE}
#CREATING THE CATEGORIES SET
cores_categorias <- data.frame(categoria = factor(c("Cities", "Isolated Urban Areas", "Urban Villages", "Rural Village", "Rural Core", "Rural Settlement", "Settlement Project", "Traditional Communities"), levels = c("Cities", "Isolated Urban Areas", "Urban Villages", "Rural Village", "Rural Core", "Rural Settlement", "Settlement Project", "Traditional Communities")), cor = c("#FF0000", "#FF4747", "#F66969", "#ED833B", "#DF9B6D", "#FFD966", "#968551", "#9CC2E5"))

#ESTABLISHING THE ORDER FOR CATEGORIES IN THE LEGEND
ordem_categorias <- c("Cities", "Isolated Urban Areas", "Urban Villages", "Rural Village", "Rural Core", "Rural Settlement", "Settlement Project", "Traditional Communities")
```

```{r include=FALSE}
#loading the shapefile
cities_shp <- st_read ("sp_countries.shp")
cities_shp
names(cities_shp)

cities_shape <- cities_shp[, c("NM_MUNICIP", "geometry")]
cities_shape
crs(cities_shape)
plot(cities_shape, col = "gray")
```

Once these operations have been carried out, we move on to mapping the data from the **populated_anthromes** set onto the shape file **cities_shape**. To build the mapping we use the *ggplot()* package and combine different functions associated with it. We highlight the main functions below, following the order of application:

1. *geom_sf ()*: loading shape file **cities_shape**;
2. *geom_point ()*: determination of the mapped points of **populated_anthromes**;
3. *scale_color_manual ()*: determination of colors and order for mapping populated anthromes;
4. *labs () and variables*: determination of graphic characteristics of the legend and mapping.

That said, the following Script presents the code for constructing the mapping and, as a result, the mapping of populated anthromes.

Script: Static Mapping of Populated anthromes in the State of São Paulo.

```{r echo=TRUE, message=FALSE, warning=FALSE}
map_anthromes <- ggplot()+
  geom_sf(data = cities_shape)+
  geom_point(data = populated_anthromes, aes(x = longitude, y = latitude, color = categoria), width = 0.01, height = 0.01, pch = 15)+
  scale_color_manual(values = setNames(cores_categorias$cor, cores_categorias$categoria), breaks = ordem_categorias, labels = ordem_categorias)+
  labs (title = "Populated Anthromes", subtitle = "Study Area: State of São Paulo (Brazil)", fill = cores_categorias$categoria)+
  xlab ("Longitude")+
  ylab ("Latitude")+
  labs (color = "Populated Anthromes")+
  theme_minimal()

print(map_anthromes)
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/map_anthromes.png", res = 300, width = 3600, height = 2400)
print(map_anthromes)
dev.off
```

Source: the authors (2023). Caption: code showing the structure used to map data from the **populated_anthromes** set onto the shapefile **cities_shape**.

The mapping generated by the code above demonstrates that the **populated_anthromes** data was overlaid on the **cities_shape** shapefile as expected. The mapping followed the guidelines for distribution of sampling points according to the longitude and latitude described in the **populated_anthromes** set, as well as the color established for each category.

It is observed, however, that some squares (points referring to populated anthromes) go beyond the areas of the shapefile **cities_shape**. This aspect was considered in the study of the uncertainty in the mapping of populated anthromes, a study that we will later present to the interactive mapping of populated anthromes.

In the next topic, we transpose static mapping to interactive mapping, in order to structure a map that can be integrated with technological services, such as websites and the GitHub collection.

## Interactive mapping of populated anthromes

Firstly, it was necessary to prepare some structures for the interactive mapping to be created next. The first of these was the structuring of the components used in the legend to be printed in the mapping. To this end, we created the set **demographic_anthromes**, which contains the names of the 8 typologies of populated anthromes that have been mapped up to this point. In addition, to define the categories and colors printed in the mapping, we used the data set described in the **legend_populatedanthromes** data frame, taking into account its previous use for plotting the data (performed in the previous item).

```{r include=FALSE}
#Criação do conjunto de tipologias territoriais a ser exibida na legenda do mapa interativo
demographic_anthromes <- c("Cities", "Isolated Urban Areas", "Urban Villages", "Rural Villages", "Rural Core", "Rural Settlement", "Settlement Project", "Traditional Communities")

#Definição das categorias e das cores a serem utilizadas no mapeamento
legend_populatedanthromes
```

Having defined these aspects, we move on to the mapping itself. To create the interactive mapping, we used the **leaflet()** package and the editable resources associated with it and we will highlight the most relevant ones. Firstly, the **addMarkers()** function helped to demarcate the points where data were found in the **demographic_anthromes** set, using the *latitude* and *longitude* attributes for plotting.

In addition, the **addRectangles()** function helped to define the position and size of the squares used to demarcate the populated anthromes. At this point, we must highlight that we used the measurement, in degrees, of **0.03** (positive and negative) to size the area squares. The choice was based on the analysis of the literature and the mapping itself, as, during the tests, we observed that for smaller degrees, the squares did not cover the surface of some cities, given the punctual nature of the **demographic_anthromes* data set. *. Therefore, we chose to use these degrees as a reference and consider them later when analyzing the uncertainty of the generated mapping.

Thus, assuming what was predicted, the first interactive mapping of Brazilian anthromes is presented below, portraying the model area of this work, that of the State of São Paulo, and the populated anthromes present in it. It was structured on the basis of *Open Street Maps*, a free, collaborative global mapping project that can be used by any user and researcher around the world. We reiterate here that our choice is meanted by the dissemination of knowledge and the reproducibility of the research carried out here, therefore, the free nature and availability of these open maps justify our choice.

Figure: Interactive Mapping of Populated anthromes in the State of São Paulo.

```{r echo=FALSE, message=FALSE, warning=FALSE}
demographic_anthromes_map <- leaflet(data = populated_anthromes) %>% addTiles() %>% addMarkers(lat = ~latitude, lng = ~longitude, popup = ~paste("categoria", categoria)) %>% addRectangles(
  lng1 = ~longitude - 0.03,
  lat1 = ~latitude - 0.03,
  lng2 = ~longitude + 0.03,
  lat2 = ~latitude + 0.03,
  color = ~legend_populatedanthromes$Cores[match(categoria, legend_populatedanthromes$Categorias)],
  fillOpacity = 0.7
) %>% clearMarkers() %>% addLegend(position = "bottomright", colors = legend_populatedanthromes$Cores, labels = demographic_anthromes, title = "Categories")

demographic_anthromes_map 
```

```{r include=FALSE}
library(htmlwidgets)

saveWidget(demographic_anthromes_map , file = "demographic_anthromes_map .html")
```

Source: the authors (2023). Caption: interactive mapping produced in R language (R Studio) where the populated anthromes present in the State of São Paulo (Brazil) are presented, a reference area for the pilot study of Brazilian anthromes. In the mapping, the squares that describe the anthropogenic sectors are presented, using degrees of 0.03 (positive and negative) for latitude and longitude to demarcate each of the squares. The legend in the mapping represents the colors visible in the mapping and the typologies of the anthropogenic sectors to which they refer.

Notoriously, the product has its limitations, however it represents in a relevant way the anthropogenic populated sectors distributed in the territory of São Paulo. Returning to the question about the dimensions of the squares present in the mapping, we carried out the calculation to size the area described by each of the squares. For this purpose, we used the average of the variables *latitude* and *longitude* that appeared in the **populated_anthromes** set as a basis for the calculations, taking into account the high number of isolated points.

Furthermore, we consider the first two formulas presented below for calculating the width and height of the square. Subsequently, based on the results, we calculate the area of the square using the third formula in the sequence.

```{r include=FALSE}
latitude <- mean(populated_anthromes$latitude)
latitude

longitude <- mean(populated_anthromes$longitude)
longitude

latitude_mean <- mean(latitude)
latitude_mean

#width of the square in km
width_km <- abs(0.03*111.32*cos(latitude_mean))
width_km

#height of the square in km
height_km <- abs(0.03*111.32)*sin(latitude_mean)
height_km

#average area of the square
mean_square_area <- width_km*height_km
mean_square_area
```

**Formulas**

$Width (longitude)=0.03×111.32×cos(mean latitude)$

$Height (latitude)=0.03×111.32×sin(mean latitude)$

$Area of the square = width×height$

AOnce the mathematical expressions are presented, the results obtained are reported below. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
cat("square width (longitude) in kilometers:", width_km, "km\n")
cat("square height (latitude) in kilometers:", height_km, "km\n")
cat("Average square area in square kilometers:", mean_square_area, "km²\n")
```

We emphasize that up to this point no mapping uncertainty studies have been carried out, this being the subsequent stage of the work. 

## Mapping validation and uncertainty studies

As established in the methodology of this work, we carried out certain procedures to evaluate and certify the quality of the regional mapping of anthromes. Following the investigative guidelines established by Lovelace, Nowosad and Muenchow (2019) and Wickham, Çetinkaya-Rundel and Grolemund (2023), we list studies to confirm the spatialization of geospatial information (distribution of population data), to evaluate the uncertainty and associated error to mapping in the eyes of Earth and Environmental Sciences and to attest to the quality of the product generated by this study. As the aforementioned authors present, these investigations are part of mapping uncertainty and validation studies, which are reported below. 

### Overlap Analysis

The initial stage of the analysis of the quality of the mapping reflects the analysis of the overlap of the mapped points of the populated anthromes of the State of São Paulo and the data from the São Paulo locations, which portray the census sectors used during the 2010 Demographic Census (IBGE, 2013) . According to the Brazilian legal apparatus (MAPA/INCRA, 2022; BRASIL, 2018; MMA, 2006; 2002), the overlap analysis proves to be a regulated instrument within the Federation to evaluate the overlap of polygons in areas registered in different institutions of government. The objective is to identify whether rural and urban properties overlap spatially in property registers (rural and urban), which could generate territorial conflicts, tax defaults, among other judicial, civic and environmental problems.

From this perspective, analyzing the overlap of populated anthromes with the raw IBGE data aims to demonstrate the alignment of the product with the urban-rural mesh of the census sectors. As can be seen from the regulations just discussed, the non-overlapping of populated areas and locations in São Paulo would portray the inaccuracy of the mapping, potentially causing the aforementioned problems for territorial planning and, consequently, for the spheres of government. Thus, following the premises of Lovelace, Nowosad and Muenchow (2019) and Wickham, Çetinkaya-Rundel and Grolemund (2023), we investigated how the points referring to populated anthromes overlap with data from the São Paulo census sectors.

Thus, we converted the raw data from **br_locations_2010** (shapefile) into a simple data set (sf) using the *st_as_sf()* function. After the conversion, we extract the data referring to the State of São Paulo, using the *filter()* function. With it, we structured the **saopaulo** data set, referring to the census sectors of the State of São Paulo. After structuring this set, here understood as a comparator, we determined the number of sample points, choosing all points (2143) as a sample for overlap analysis.

Having determined the sampling points of the comparator (**saopaulo**), we established the coordinate system (CRS) of 4326, the same as the **populated_anthromes** data. The following Figure demonstrates the number of sample points (IBGE raw data) established for overlap analysis and their spatial distribution. The choice for purple comes from the fact that this color is not included in any of the data sets worked on so far.. 

```{r message=FALSE, warning=FALSE, include=FALSE}
#estruturando o comparador no formato sf
localbr_sf = st_as_sf(br_locations_2010)
localbr_sf

saopaulo <- localbr_sf %>% filter(state == "S\xc3O PAULO")
saopaulo <- st_set_crs(saopaulo, 4326)
saopaulo$state <- replace(saopaulo$state, saopaulo$state == "S\xc3O PAULO", "SAO PAULO")
saopaulo
```

Figure: Sample points from raw IBGE data (**localities_br**)

```{r echo=FALSE, message=FALSE, warning=FALSE}
map_sp <- ggplot()+
  geom_point(data = saopaulo, aes(x = saopaulo$LONG, y = saopaulo$LAT), color = "purple", width = 0.03, height = 0.03, pch = 15)+
  labs (title = "Sample Points", subtitle = "Data extracted from São Paulo")+
  xlab ("Longitude")+
  ylab ("Latitude")+
  labs (color = "Sample Points")+
  theme_minimal()

print(map_sp)
```

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/sampling_points.png", res = 300, width = 3600, height = 2400)
print(map_sp)
dev.off
```

Source: the authors (2023). Caption: figure showing the distribution (spatialization) of the points established for the overlap analysis with the points referring to populated anthromes.

After structuring the sampling points for overlap analysis, we retrieved the data from **map_anthromes**, that is, the mapped data of the populated anthromes. In order not to generate conflicts, the layer with the shapefile of the municipalities in the State of São Paulo was removed, leaving only the squares referring to the areas of populated anthromes.

Starting from the mapping, we built a simple data set, using the dimensions x and y as latitude and longitude parameters and determining the CRS 4326 as the associated coordinate system, even from the sample/comparator set and the mappings produced in the previous item (mapping of anthromes) .

```{r include=FALSE}
map_anthromes_2 <- ggplot()+
  geom_point(data = populated_anthromes, aes(x = longitude, y = latitude, color = categoria), width = 0.03, height = 0.03, pch = 15)+
  scale_color_manual(values = setNames(cores_categorias$cor, cores_categorias$categoria), breaks = ordem_categorias, labels = ordem_categorias)+
  labs (title = "Populated Anthromes", subtitle = "Study Area: State of São Paulo (Brazil)", fill = cores_categorias$categoria)+
  xlab ("Longitude")+
  ylab ("Latitude")+
  labs (color = "Populated Anthromes")+
  theme_minimal()

print(map_anthromes_2)
```
 
```{r include=FALSE}
#extraindo os dados do gráfico ggplot
map_anthromes_data <- ggplot_build(map_anthromes_2)$data[[1]]
map_anthromes_data
#criando um objeto sf a partir de map_anthromes_data
anthromes_data_sf <- st_as_sf(map_anthromes_data, coords = c("x", "y"), crs = 4326)
```

```{r eval=FALSE, include=FALSE}
anthromes_data_sf #dados da pesquisa
saopaulo #padrão ouro - dados IBGE
```

Having established the two sets of geographic information, populated anthromes (anthromes_data_sf) and sample (**sample_sf**), we proceeded to compare them both. Firstly, it was verified whether both had the same CRS associated with their structures, as, through the CRS it is possible to identify whether geospatial information is distributed in the same area and whether they overlap within it during spatialization. Assuming this, we perform the comparison using the if()/else() functions to compare the two sets of data. The script reveals the structure of the function and presents the result through the sentence that we indicate as an answer to the if/else question.

Script: Comparison of the CRS of the sets **anthromes_data_sf** and **amostra_sf**.

```{r echo=FALSE, message=FALSE, warning=FALSE}
crs_anthromes_data_sf <- st_crs(anthromes_data_sf)
crs_saopaulo <- st_crs(saopaulo)

if (identical(crs_anthromes_data_sf,crs_saopaulo)){print("the CRS are the same")} else {print("the CRS are different")}
```
Source: the authors (2023). Caption: script presenting the construction of the if()/else() function for comparison between the two sets in relation to the geographic referencing system (CRS).

Having confirmed that the CRS of the two sets are the same, we proceed to the overlap analysis. To do this, using the *st_join()* function, we combine the two sets (**anthromes_data_sf** and **amostra_sf**) into a single simple data set (sf), which was named **juncao_sp** . 

```{r include=FALSE}
juncao_sp <- st_join(saopaulo, anthromes_data_sf)
```

Starting from joining, we summarized the data using summarize(), indicating that there was a count of points grouped by coordinates (group_by(LAT&LONG) - latitude and longitude). The product of this code indicates how many points overlap, using the point coordinates (latitude and longitude) as a reference. The following script shows the organization of the function to identify the number of points and then the numbers of overlapping points are presented.

Script: Count of overlapping points between sets.

```{r echo=FALSE, message=FALSE, warning=FALSE}
tabela_contagem_sp <- juncao_sp %>%  group_by(LAT&LONG) %>% summarize(contagem_de_pontos = n())
tabela_contagem_sp

```

Source: the authors (2023). Caption: script describing the function for analyzing the number of overlapping points between the two data sets (**anthromes_data_sf** and **saopaulo**), followed by the tabulated result of the comparison.

According to the results generated by the function, we observed that the 2143 sampled points overlapped with the points coming from populated anthromes (**populated_anthromes**). After verifying the number of overlapping points, the literature suggests that the results be visually evaluated, in order to verify the accuracy of the data overlap.

Considering this, we organize the sets to visualize the overlapping of points. First, we join the set **tablea_contagem_sp** with the data from **saopaulo**, producing the set **map_results_sp**, which represents the aggregated data. 

```{r include=FALSE}
map_results_sp <- st_join(saopaulo, tabela_contagem_sp)
```

Sequentially, using the *ggplot()* function, we structure the mapping to visualize the overlapping of points. Data from **map_results_sp** were plotted in dark green (*darkgree*) and data from populated anthromes (**anthromes_data_sf**) in red (*red*). In order to facilitate the visualization of the overlapping points, we chose to increase the dimension of the points from **map_results_sp** to 2 and reduce the points from **anthromes_data_sf** to 0.5, that is, the first ones were plotted in significantly larger dimensions than the seconds. Thus, the following script presents the code and, subsequently, the visualization of the overlapping of data from the two sets.

Script: Visualization of overlapping points between the two data sets.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(map_results_sp)+
  geom_sf(data = cities_shape)+
  geom_sf(data = map_results_sp, aes(fill = LAT&LONG),color = "darkgreen", size = 2)+
  geom_sf(data = anthromes_data_sf, color = "red", size = 0.5)+
  labs(title = "Area Point Count Map", caption = "anthromes populated in red / sample data in green")+
  theme_minimal()
```

Source: the authors (2023). Caption: script presenting the structure for mapping data compared by overlap analysis and generated mapping allowing the visualization of overlapping points in the territory of the State of São Paulo.

By mapping the overlapping data, we observed that the **anthromes_data_sf** points (derived from **populated_anthromes**, in red) are overlapping with the IBGE gold standard (raw data from **saopaulo**, mapped in dark green). Thus, the visualization of the overlapping points made it possible to verify that the spatialization of data referring to populated anthromes occurs appropriately, following the same geographic coordinates as the **saopaulo** data and distributed throughout the territory of São Paulo , as seen on the **cities_shape** shapefile layer. Thus, visual confirmation brought indications that point to the validation of the mapping at first. 

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/mapa_contagem_de_pontos.png", res = 300, width = 3600, height = 2400)
ggplot(map_results_sp)+
  geom_sf(data = cities_shape)+
  geom_sf(data = map_results_sp, aes(fill = LAT&LONG),color = "darkgreen", size = 2)+
  geom_sf(data = anthromes_data_sf, color = "red", size = 0.5)+
  labs(title = "Area Point Count Map", caption = "anthromes populated in red / sample data in green")+
  theme_minimal()
dev.off
```

### Examination of data properties

In order to ensure data quality and accuracy in mapping the geospatial information of populated anthromes, we carried out examinations on the properties of overlapping data sets, i.e. the populated anthromes data (**populated_anthromes, map_anthromes_data, anthromes_data_sf**) and the gold standard based on IBGE data (**saopaulo**). As we highlighted previously, the data sets have the same geographic coordinate system (CRS) associated with their structures. Furthermore, they both have spatial dimensions of latitude and longitude, which allowed the insertion of points in the mapping.

Continuing the analysis, we carried out the verification of the geographic limits (coordinates), which aims to prove that both sets represent the same territorial area of the mapping, that is, that the two sets have the same latitude and longitude information in their geographic referencing structure. From this perspective, using data from **populated_anthromes** and **saopaulo**, we performed the analysis using the *range()* function, which brings the minimum and maximum limits of the investigated parameters, which in this case were **latitude /LAT** and **longitude/LONG** (Frame).

```{r eval=FALSE, include=FALSE}
nrow(populated_anthromes)
nrow (saopaulo)
```

Table: Minimum and maximum latitude and longitude limits of the **populated_anthromes** and **saopaulo** sets.

```{r echo=FALSE, message=FALSE, warning=FALSE}
cat("Maximum and minimum latitude of populated_anthromes:", range(populated_anthromes$latitude), "\n")
cat("Maximum and minimum latitude of São Paulo:", range(saopaulo$LAT), "\n")
cat("Maximum and minimum longitude of populated_anthromes:", range(populated_anthromes$longitude), "\n")
cat("Maximum and minimum longitude of saopaulo:", range(saopaulo$LONG), "\n")
```

Source: the authors (2023). Caption: table showing the minimum and maximum limits of latitude and longitude of the two sets of data analyzed using the *range()* function.

The information from the *range()* function confirms that the minimum and maximum limits, both for longitude and latitude, are the same for both sets. Continuing with the verification, we use the *summary()* function to analyze extreme statistical values associated with the two sets (Script). Just as we performed the analysis using the *range()* function, here we consider the **latitude** and **longitude** information of the two sets.

Script: Application of the *summary()* function to analyze extreme values.

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(populated_anthromes$latitude)
summary(saopaulo$LAT)
summary(populated_anthromes$longitude)
summary(saopaulo$LONG)
```

Source: the authors (2023). Caption: code for statistical summary of **populated_anthromes** and **saopaulo** data, presenting the *minimum, first quartile, mean, mean, third quartile* and *maximum* values.

We verified that the results obtained are synergistic, with small differences in the *third quartile* of latitude (0.01) and the *mean* of longitude (0.01). This difference is associated with the number of points described by the two sets, as **populated_anthromes** is made up of 2141 points, while **saopaulo** is made up of 2143.

```{r echo=FALSE, message=FALSE, warning=FALSE}
missing_lines <- anti_join(saopaulo, populated_anthromes, by = "ID")
missing_lines
```

Performing the analysis of the sets to identify the missing lines in **populated_anthromes**, we observed that the two lines from **saopaulo** refer to two isolated urban areas (AUI) in the municipality of Estiva Gerbi (district area of Moji Mirim ). According to population data01, a set used to associate demographic density with populated areas (census sectors), AUI data are clusters and associated with a point, which can describe more than one location. Therefore, the error (or spatial limitation) is due to this aspect of data clustering and is represented in the following Figure.

Figure: Mapped representation of missing points in **populated_anthromes**.

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot() +
  geom_sf(data = cities_shape)+
  geom_point(data = populated_anthromes, aes(x = longitude, y = latitude, color = "Populated Anthromes"), size = 2) +
  geom_point(data = saopaulo, aes(x = LONG, y = LAT, color = "Golden Pattern"), size = 1) +
  geom_point(data = missing_lines, aes(x = LONG, y = LAT, color = "Golden Pattern"), size = 2) +
  scale_color_manual(values = c("Populated Anthromes" = "green", "Golden Pattern" = "blue", "Missing Points" = "red")) +
  labs(title = "Overlap analysis: missing points") +
  theme_minimal()+
  theme(legend.title = element_blank())
```

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/missing_points.png", res = 300, width = 3600, height = 2400)
ggplot() +
  geom_sf(data = cities_shape)+
  geom_point(data = populated_anthromes, aes(x = longitude, y = latitude, color = "Populated Anthromes"), size = 2) +
  geom_point(data = saopaulo, aes(x = LONG, y = LAT, color = "Golden Pattern"), size = 1) +
  geom_point(data = missing_lines, aes(x = LONG, y = LAT, color = "Golden Pattern"), size = 2) +
  scale_color_manual(values = c("Populated Anthromes" = "green", "Golden Pattern" = "blue", "Missing Points" = "red")) +
  labs(title = "Overlap analysis: missing points") +
  theme_minimal()+
  theme(legend.title = element_blank())
dev.off
```

Source: the authors (2023). Caption: figure presenting the summary of the overlap analysis, where the two missing points in **populated_anthromes** and in **saopaulo** are indicated in red.

## Mapping summary statistics

Deepening our statistical analyzes on the mapping of São Paulo's anthromes, considering data from the Brazilian Demographic Census (IBGE, 2013) as the gold standard, we move on to **Summary Statistics**. To carry them out, we established a statistical grid over the territory of São Paulo, using data from **saopaulo** (simple data set - *sf* - derived from **br_locations_2010**, our comparator or gold standard). This grid was built on the basis of 400 cells (20 by 20), considering the spherical scale, as we will present below.

First, we convert the set **saopaulo** into a spatial object (from English, *spatial*), using the function *as(_, "spatial")*, giving rise to the set **saopaulo_spatial** . Starting from this, we establish the minimum and maximum X and Y values (longitude and latitude, respectively).

Having established the minimum and maximum values of statistical grid). With this calculation we arrive at the values **size_cell_x** and **size_cell_y**, representing the width (longitude) and height (latitude) of the statistical grid square.

It is noteworthy that in these calculations on the size of the squares (cells) of the statistical grid, the sphericity of the Earth was considered, deriving the formulas used here from the Haversine Formula, which is commonly used to calculate the distance between two points. The global structure of this formula is represented as follows:

\[ a = \sin^2\left(\frac{\Delta\text{lat}}{2}\right) + \cos(\text{lat}_1) \cdot \cos(\text{lat}_2) \cdot \sin^2\left(\frac{\Delta\text{lon}}{2}\right) \]

\[ c = 2 \cdot \text{atan2}\left(\sqrt{a}, \sqrt{1-a}\right) \]

\[ d = R \cdot c \]

where:
- \(\Delta\text{lat}\) is the difference in latitude between the two points,
- \(\Delta\text{lon}\) is the difference in longitude between the two points,
- \(\text{lat}_1\) e \(\text{lat}_2\) are the latitudes of the two points in radians,
- \(R\) is the radius of the sphere (for example, the average radius of the Earth).

In this way, we were able to size the distances between two points of longitude and latitude, arriving at the width and height dimensions of the grid cells and, therefore, we were able to size the approximate area of each of them. The dimensional values obtained from the calculations performed are presented below. 

```{r include=FALSE}
saopaulo
saopaulo_spatial <- as (saopaulo, "Spatial")
saopaulo_spatial
```

```{r include=FALSE}
# 2. Definir limites geográficos
xmin <- min(saopaulo_spatial$LONG)
xmax <- max(saopaulo_spatial$LONG)
ymin <- min(saopaulo_spatial$LAT)
ymax <- max(saopaulo_spatial$LAT)
```

```{r include=FALSE}
# Calculate cell size
cell_size_x <- (xmax - xmin) / 20
cell_size_y <- (ymax - ymin) / 20

# Average latitude of the area (in degrees)
grid_mean_latitude <- mean(saopaulo$LAT)

# Conversion factor for latitude (in km per degree)
conversion_factor_per_degree_latitude <- 111.32 * sin(latitude_mean * pi / 180)

# Conversion factor for longitude (in km per degree)
conversion_factor_per_degree_longitude <- 111.32 * cos(latitude_mean * pi / 180)

# Convert cell sizes from degrees to kilometers
cell_size_x_km <- abs(cell_size_x * conversion_factor_per_degree_longitude)
cell_size_y_km <- abs(cell_size_y * conversion_factor_per_degree_latitude)

# Area of each quadrant in square kilometers (km²)
quadrant_area_km2 <- cell_size_x_km * cell_size_y_km

# Side of the grid square in kilometers (km)
side_grid_square_km <- sqrt(quadrant_area_km2)
```

Table: Cell dimensions in a 20x20 statistical grid (400 cells). 

```{r echo=FALSE}
# results
cat("Cell size (quadrant) in kilometers (km):\n")
cat("width (cell_size_x_km):", cell_size_x_km, "km\n")
cat("height(cell_size_y_km):", cell_size_y_km, "km\n\n")
cat("Area of each quadrant of the grid in km²:", quadrant_area_km2, "km²\n")
cat("Average dimension of the sides of the grid square in km:", side_grid_square_km, "km\n")
```

Source: the authors. Legend: table representing the values obtained during the dimensioning of the height, width and area of the cells of the statistical grid structured in 20x20 (400).

Furthermore, with these dimensions we structured the statistical grid with 400 cells using the *raster()* function, which was named **quadrant_grid** and was used in subsequent calculations. Additionally, it was necessary to structure the XY ordered pairs of the statistical grid so that we could visualize the cells in the plot, which was done using the *as.data.frame()* function.

```{r include=FALSE}
#Criar a grade de quadrantes
quadrant_grid <- raster(extent(xmin, xmax, ymin, ymax), res = c(cell_size_x, cell_size_y))

# Converta a grade para um quadro de dados
quadrant_grid_df <- as.data.frame(quadrant_grid, xy = TRUE)
```

After establishing the statistical grid with 400 cells, we started counting points in each cell. The objective was to identify the distribution behavior of anthromes mapping points compared to the gold standard (IBGE data). This count was carried out in two moments, the first for data from **saopaulo** and the second for **populated_anthromes**.

Using the *rasterize()* function, we count points per quadrant in **saopaulo**. The count allowed the construction of a data frame with 2 columns and 400 rows, in which the columns represent the cells (400) and the number of points in each of them. Thus, each of the lines refers to one of the cells in the statistical grid. 

```{r include=FALSE}
# Point count using the rasterize function and the saopaulo_spatial data frame:
quadrant_counting_saopaulo <- rasterize(saopaulo_spatial, quadrant_grid, fun = "count")
print(quadrant_counting_saopaulo)

# Conversion of the result into a data frame
quadrant_counting_saopaulo_df <- as.data.frame(quadrant_counting_saopaulo)

# Renaming the columns of the quadrant_counting_saopaulo_df data frame
colnames(quadrant_counting_saopaulo_df) <- c("Cell", "Counting")

# Isolating the two columns (cell and count) into a single object (saopaulo_countpoints)
saopaulo_countpoints <- quadrant_counting_saopaulo_df[, c("Cell", "Counting")]

# Establishing the order of cell numbers (1 to 400)
saopaulo_countpoints$Célula <- 1:400
saopaulo_countpoints
```

```{r message=FALSE, warning=FALSE, include=FALSE}
sp_point_count <- ggplot() +
  geom_raster(data = quadrant_grid_df, aes(x = x, y = y, fill = saopaulo_countpoints$Counting)) +
  geom_text(data = quadrant_grid_df, aes(x = x, y = y, label = saopaulo_countpoints$Counting), size = 2) +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Grid with São Paulo Point Count (Gold Standard)", fill = "number of points") +
  theme_minimal()

print(sp_point_count)
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/sp_point_count.png", res = 300, width = 3600, height = 2400)
print(sp_point_count)
dev.off
```

After counting **saopaulo** points, we performed a similar procedure with the data from **populated_anthromes**. Firstly, this set was converted into a spatial object (*spatial*), using the *st_as_sf()* function, structuring the **populated_anthromes_spatial** object. Sequentially, the *rasterize()* function led to the counting of points in the statistical grid for the populated anthromes, generating the **count_by_quadrant_anthromes** data frame. Again, the cell information and number of points per cell were isolated in a set referring to data from populated anthromes (**anthromes_countpoints**). With this data, we were able to map the distribution of points on the statistical grid of anthromes. 

```{r include=FALSE}
# Conversion to spatial type object
populated_anthromes_spatial <- st_as_sf(populated_anthromes, coords = c("longitude", "latitude"))
populated_anthromes_spatial

# Point count per quadrant
quadrant_counting_anthromes <- rasterize(populated_anthromes_spatial, quadrant_grid, fun = "count")
print(quadrant_counting_anthromes)

# Convert the result to a data frame
quadrant_counting_anthromes_df <- as.data.frame(quadrant_counting_anthromes)

# Rename the columns
colnames(quadrant_counting_anthromes_df) <- c("Cell", "Counting")

# Isolate the two columns in a new data frame
anthromes_countpoints <- quadrant_counting_anthromes_df[, c("Cell", "Counting")]

# Create a new cell column with numbers from 1 to 400
anthromes_countpoints$Célula <- 1:400
anthromes_countpoints
```

```{r message=FALSE, warning=FALSE, include=FALSE}
anthromes_point_count <- ggplot() +
  geom_raster(data = quadrant_grid_df, aes(x = x, y = y, fill = anthromes_countpoints$Counting)) +
  geom_text(data = quadrant_grid_df, aes(x = x, y = y, label = anthromes_countpoints$Counting), size = 2) +
  scale_fill_gradient(low = "white", high = "#FF0000") +
  labs(title = "Grid with Counting Points of Populated Anthromes", fill = "number of points") +
  theme_minimal()

print(anthromes_point_count)
```

```{r include=FALSE}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/anthromes_point_count.png", res = 300, width = 3600, height = 2400)
print(anthromes_point_count)
dev.off
```

The following figure illustrates the Statistical Grid with the Point Count for **saopaulo** (gold standard) and for **populated_anthromes**. Comparatively, we observed that some of the points referring to the gold standard are counted in other cells in the populated anthromes. Famously, this difference is associated with the EPSG structure in which the two sets were found. As we mentioned previously, the CRS were different between the two sets (gold standard and populated anthromes) and adjustments were made throughout the analyses. This generated small distortions in the distribution of points, in a few cases, as we will demonstrate through other metrics about the mapping.

Figure: Statistical Grids with Point Counts of the Gold Standard and Populated anthromes of the State of São Paulo.

```{r echo=FALSE, warning=FALSE}
par(mfrow=c(1,2))
print(sp_point_count)
print(anthromes_point_count)
```

Source: the authors (2023). Caption: Figure representing the statistical grid with the point count of (a) **saopaulo** (gold standard) and (b) **populated_anthromes**, both referring to the State of São Paulo. The colored areas represent the color gradient according to the number of points in the grid cells. The gray areas represent the cells where there were no points, that is, areas that went beyond the analysis area of the perimeter of the State of São Paulo and, consequently, of the populated anthromes of the Federation Unit. 

### Structuring the Confusion Matrix for Statistical Analysis

First, we combined the two data sets associated with point counting (**saopaulo_countpoints** and **anthromes_countpoints**). The purpose of combining the two sets was to structure the **confusion matrix** for statistical analyses. In it, we aligned the numbers of points in each cell of the statistical grid (20x20) of the two sets, in order to establish the following relationships:

1. True Positives (TPs): quadrants of the statistical grid where the number of points is equal between **saopaulo_countpoints** and **anthromes_countpoints**;
2. True Negatives (TNs): quadrants of the statistical grid where there are no points represented in both **saopaulo_countpoints** and **anthromes_countpoints**;
3. False Negatives (FNs): quadrants of the statistical grid where the number of points in **saopaulo_countpoints** is greater than the number of points in **anthromes_countpoints**.
4. False Positives (FPs): quadrants of the statistical grid where the number of points in **saopaulo_countpoints** is smaller than the number of points in **anthromes_countpoints**.

To structure these relationships, we use the *ifelse()* function. If the number of points were equal and different from 0 in both sets to determine if the values are equal (TP) or different (TN), greater (FN) or smaller (FP) in **saopaulo_countpoints** when compared to ** anthromes_countpoints**.

If the number of points were equal in both sets and different from 0, the TP column would receive the value of 1 and the TN, FP and FN columns would receive the value of 0. If the number of points were equal to 0 in both sets, the column TN would receive the value of 1 and TP, FN and FP of 0. Additionally, if the number of points in the grid quadrant were greater **saopaulo_countpoints** than in **anthromes_countpoints**, the FN column would also receive the value of 1 and the TP, TN and FP columns the value of 0. On the other hand, if the number of points were smaller in **saopaulo_countpoints** than in **anthromes_countpoints**, the FP column would receive the value of 1 and the columns TP, TN and FN the value of 0.

It should be noted that in the statistical grid there were areas that did not represent the data from São Paulo (areas in gray in the Figure above), that is, lines where "NA" appeared. These lines were replaced by 0 in the combined set using the function **[is.na(combined_set)] <- 0**, in order to allow statistical calculations based on the confusion matrix. The following table illustrates the confusion matrix structured by this operation.

```{r include=FALSE}
# Combining the saopaulo_countpoints and anthromes_countpoints sets
combined_set <- data.frame(Celula = 1:400, saopaulo_countpoints = saopaulo_countpoints$Counting,anthromes_countpoints = anthromes_countpoints$Counting)
combined_set[is.na(combined_set)] <- 0

# Calculating the values of TP, TN, FN and FP
combined_set$TP <- ifelse(combined_set$saopaulo_countpoints == combined_set$anthromes_countpoints & combined_set$saopaulo_countpoints != 0, 1, 0)
combined_set$TN <- ifelse(combined_set$saopaulo_countpoints == 0 & combined_set$anthromes_countpoints == 0, 1, 0)
combined_set$FN <- ifelse(combined_set$saopaulo_countpoints > combined_set$anthromes_countpoints, 1, 0)
combined_set$FP <- ifelse(combined_set$saopaulo_countpoints < combined_set$anthromes_countpoints, 1, 0)
```

Table: Confusion Matrix

```{r echo=FALSE}
print(combined_set)
```

Source: the authors (2023). Legend: Confusion matrix structured from the alignment by cells of **saopaulo_countpoints** and **anthromes_countpoints**. The table displays the first 10 rows of the set of 400 rows (statistical grid cells).

### Mapping Sensitivity

After structuring the confusion matrix, we proceeded to analyze the sensitivity of mapping in a 20x20 statistical grid for the State of São Paulo. The calculation of mapping sensitivity aims to evaluate the model's ability to identify true positives (TPs), that is, through this metric it is possible to evaluate whether the mapping of anthromes in São Paulo can efficiently identify the points present in the territory of São Paulo (gold standard). The estimate of this metric was made using the formula:

$$\text{Sensitivity (Recall)} = \frac{TP}{TP + FN}$$

where TP represents true positives and FN represents false positives.


```{r}
# Calculating sensitivity
sensitivity <- sum(combined_set$TP) / (sum(combined_set$TP) + sum(combined_set$FN))

# Displaying the result
sensitivity
```

Through the sensitivity calculation, we obtained the value of **0.9951691**, that is, approximately **99.52%** of the gold standard points are captured within the populated anthromes points. Using this metric, we confirm that the model used in mapping populated anthromes in the State of São Paulo is capable of identifying areas similarly represented by the gold standard, consequently pointing to the quality of the mapping and the sensitivity of the method.  

### Mapping Specificity

Continuing the statistical analyzes regarding the mapping of populated anthromes in the State of São Paulo, we move on to the analysis of the specificity of the mapping. According to the literature, this metric refers to the model's ability to identify mapped points that are not part of the comparison standard (gold standard). From this perspective, the specificity analysis aimed to identify whether the model used in the mapping (**populated_anthromes**) is capable of pointing out which points are not included in the same cell of the statistical grid as the gold standard (**saopaulo**).

In this way, we returned to the **combined_set** for analysis, where the proportion of points identified as True Negatives (TNs) in relation to the number of False Positive points (FPs) was verified. In other words, we analyzed the proportion between the quadrants in which the number of gold standard points was greater compared to the quadrants where the number of anthromes points was greater (FPs). The formula used to estimate specificity is represented by the formula: 

$$\text{Specificity} = \frac{TN}{TN + FP}$$

where TN represents the number of quadrants identified as True Negatives and FN the number of False Positives.

```{r echo=TRUE}
# Calculating Specificity
specificity <- sum(combined_set$TN) / (sum(combined_set$TN) + sum(combined_set$FP))

# Displaying the result
print(specificity)
```

The result obtained for the mapping *specificity* metric was **0.9896373**, that is, in the quadrants of the statistical grid where there are no points plotted by the gold standard, the model used for mapping anthromes operates with a proportion of * *98.96%** accuracy, correctly classifying the absence of points in these areas. It is also considered that this value indicates that there are quadrants where the points mapped by **anthromes_countpoints** exceed the number of points that make up **saopaulo_countpoints**; This indication refers to the overlap analysis carried out previously, where we demonstrated that some points were distorted during the spatial distribution (latitude and longitude of the points on the map) and, when we established the statistical grid, they framed cells different from those of the gold standard.

Therefore, despite the limitations just discussed, we observed that this metric also contributes to inferring the quality of the model used in mapping, demonstrating its suitability for the intended use.

### Global Mapping Accuracy and Error

Advancing in the statistical analyses, we enter the *global accuracy* metric of the mapping. According to the literature, this metric aims to identify the proportion of points that were correctly identified by anthromes mapping when compared to the gold standard. In other words, this metric estimates the number of True Positives (TPs) compared to the total number of cells in the grid. The calculation of global accuracy is done using the formula:

$$\text{Global Accuracy} = \frac{TP + TN}{TP + TN + FP + FN}$$

where TP, which represents the grid cells in which the number of points is equal in anthromes mapping and in the gold standard, is divided by the total cells of the statistical grid, that is, by the sum of cells with the same number of points (TPs) and different (FPs and FNs) between the sets. 

```{r echo=TRUE}
# Calculating Global Accuracy
global_accuracy <- (sum(combined_set$TP) + sum(combined_set$TN)) / (sum(combined_set$TP) + sum(combined_set$TN) + sum(combined_set$FP) + sum(combined_set$FN))

# Displaying the result
print(global_accuracy)
```

Based on the estimate of *global accuracy*, we obtained the result of **0.9925**, that is, approximately **99.25%** of the points mapped for anthromes are correctly mapped in the State of São Paulo when compared to the standard gold. This proportion demonstrates that there is a high correspondence rate between the mapped data, pointing to the quality of the product generated for the anthromes in the Federation Unit.

Assuming this, we proceed to calculate the *global error*, which, according to the literature, indicates the proportion of areas classified incorrectly by the model. In other words, this metric uses the proportion between False Positives (FPs) and False Negatives (FNs) compared to the total number of cells in the statistical grid. The calculation of the global error is given by the formula:

$$\text{Global Error} = \frac{FP + FN}{TP + TN + FP + FN}$$

where we have the sum of FPs and FNs, areas with a divergent number of points between anthromes and the gold standard, divided by the total number of cells with points.

```{r}
# Calculating the Global Error
global_error <- (sum(combined_set$FP) + sum(combined_set$FN)) / (sum(combined_set$TP) + sum(combined_set$TN) + sum(combined_set$FP) + sum(combined_set$FN))

# Displaying the result
  print(global_error)
```

Through calculations of the *global error* we obtained an estimate of **0.0075**, that is, only **0.75%** of the areas mapped in populated anthromes were classified incorrectly when compared to the IBGE gold standard. This value indicates the model's low error rate and points to the accuracy of the mapping of anthromes, reinforcing the notes on the quality of the mapping. 

## Summary of Mapping Statistics and Visualization of Results

Throughout the analyzes on the statistical metrics of the mapping, namely: *sensitivity*, *specificity*, *global accuracy* and *global error*; We observed promising results for the model used in mapping the anthromes populated in the State of São Paulo, as evidenced by the following table.

Table: Results of the Statistical Metrics of the Model for Mapping Populated Anthromes.

```{r echo=FALSE}
#Criando a tabela com os results obtidos para as métricas estatísticas
results <- data.frame(
  Metrics = c("Sensitivity", "Specificity", "Global Accuracy", "Global Error"),
  Estimation = c(sensitivity, specificity, global_accuracy, global_error),
    Percentage = paste0(round(c(sensitivity, specificity, global_accuracy, global_error) * 100, 2), "%"))

#Exibindo a tabela
results
```

Source: the authors (2023). Legend: table with a summary of the results obtained for the four statistical metrics analyzed, namely: *sensitivity, specificity, global accuracy and global error*. The results are presented in two formats, the estimate and the percentage (with two decimal places).

According to other work that involves such metrics in mapping, whether for validation of the product (cartography) or for analysis of the model (map production structure), it appears that the estimates for the model of populated anthromes align compliance with the requirements for suitability for the intended use, reflecting the quality of the distribution of points and the efficiency of their representation.

Below we present the bar graph referring to the metrics presented in the table. As can be seen, the *global error* appears to be the only metric closest to zero, which according to the literature is significantly positive, given the low distortion rate of the product (populated anthromes) compared to the standard gold (IBGE data).

On the other hand, it is noted that *sensitivity*, *specificity* and *global accuracy* are close to 1. According to the literature, when approaching 1, the better the model's ability to represent the data, following comparator guidelines (gold standard). Therefore, the anthromes model meets these premises and is capable of meeting the specifications of these metrics with relevant efficiency.

Graph: Statistical Metrics Results.

```{r echo=FALSE}
# Defining the colors of each metric
metrics_colors <- c("sensitivity" = "blue", "specificity" = "green", "global accuracy" = "red", "global error" = "purple")

# Creating the bar chart
ggplot(results, aes(x = Metrics, y = Estimation, fill = Metrics)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = metrics_colors) +
  labs(title = "Results of the Evaluation Metrics", y = "Result", x = NULL) +
  theme_minimal()
```

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/demographic_anthromes_bar_chart.png", res = 300, width = 3600, height = 2400)
ggplot(results, aes(x = Metrics, y = Estimation, fill = Metrics)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = metrics_colors) +
  labs(title = "Results of the Evaluation Metrics", y = "Result", x = NULL) +
  theme_minimal()
dev.off
```

Source: the authors (2023). Legend: Bar graph summarizing the estimates obtained for the statistical metrics used in the analysis of mapping quality, namely: *global accuracy* (red), *global error* (purple), *specificity* (green) and *sensitivity* (blue).

Another visualization pattern that seemed relevant to present the estimates obtained for the analyzed metrics was the Radar chart. In it, the four metrics are presented simultaneously on a target, in which the center represents the value of 0 and the last circle from the inside to the outside the value of 1. This standard is commonly used by Metrology to analyze the measurement capacity of a given method. or instrument. As this is one of the Sciences that are part of our analytical core and that consolidates our view of Environmental Sciences and Human Ecology, we absorb such graphic modeling in the analyses, reinforcing our effort to align these Sciences.

Chart: Radar Chart of Metrics Investigated.

```{r echo=FALSE}
# Creating the set with estimates and metrics
metrics <- data.frame(metric = c("sensitivity", "specificity", "global accuracy", "global error"),  values = c(sensitivity, specificity, global_accuracy, global_error))

# Normalizing the values
metrics$values <- (metrics$values - min(metrics$values)) / (max(metrics$values) - min(metrics$values))
```

```{r echo=FALSE}
# Creating the radar chart
ggplot(metrics, aes(x = metric, y = values)) +
  geom_polygon(fill = "blue", color = "blue", alpha = 2) +
  geom_path(color = "blue") +
  geom_point(size = 3, color = "red") +
  coord_polar() +
  labs(title = "Assessment Metrics Radar Chart") +
  theme_minimal() +
  theme(axis.text = element_text(size = 10),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0))
```

Source: the authors (2023). Legend: radar graph of statistical metrics to validate the mapping and model analyzed. The graph reports the estimates obtained for *sensitivity*, *specificity*, *global accuracy* and *global error*.

As shown in the table previously, the values for *sensitivity*, *specificity* and *global accuracy* are close to one, giving the impression that these values are at 1 (last circle from inside to outside) in the pattern radar graph display. Otherwise, the value of the *global error* being close to 0 is at the center of the graphic model, reiterating the statements made and assuming the interpretative premises of the graphic model from the literature.

```{r include=FALSE}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02.1 DEMOGRAPHIC/demographic_anthromes_radar.png", res = 300, width = 3600, height = 2400)
ggplot(metrics, aes(x = metric, y = values)) +
  geom_polygon(fill = "blue", color = "blue", alpha = 2) +
  geom_path(color = "blue") +
  geom_point(size = 3, color = "red") +
  coord_polar() +
  labs(title = "Assessment Metrics Radar Chart") +
  theme_minimal() +
  theme(axis.text = element_text(size = 10),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0))
dev.off
```

With this, we conclude our analyzes regarding the mapping of populated anthromes. Throughout this analysis, we processed and mined data from the 2010 Demographic Census (IBGE, 2013), classifying geospatial data into different types of populated anthromes, following the guidelines established by Ellis (2020) for classification and IBGE metadata. for alignment. Subsequently, we plotted the classified data and, sequentially, static and interactive mapping of populated anthromes in the State of São Paulo.

Once the mapping construction stages were completed, we moved on to statistical analysis to validate the cartographic product. At this point, we carried out the overlap analysis, comparing the cartography of populated anthromes to the gold standard, which was stipulated based on IBGE data. We identified some distortions in the data set and, consequently, in the mapping, but which do not invalidate the product of this Thesis; however, it appears to be a limitation of the product.

Sequentially, we analyzed the statistical metrics of sensitivity, specificity, global accuracy and global error. The estimates obtained for these metrics showed that the model has relevant suitability for the intended use of mapping demographic information, efficiently performing the distribution of points in the cartography and the mapping of census information, when compared to the gold standard. The small distortions identified at this stage also appear to be modeling limitations, but do not invalidate the modeling used to map populated anthromes.  

# Conclusions

Throughout this analysis, we processed and mined data from the 2010 Demographic Census (IBGE, 2013), classifying geospatial data into different types of populated anthromes, following the guidelines established by Ellis (2020) for classification and IBGE metadata. for alignment. Subsequently, we plotted the classified data and, sequentially, static and interactive mapping of populated anthromes in the State of São Paulo.

  Once the mapping construction stages were completed, we moved on to statistical analysis to validate the cartographic product. At this point, we carried out the overlap analysis, comparing the cartography of populated anthromes to the gold standard, which was stipulated based on IBGE data. We identified some distortions in the data set and, consequently, in the mapping, but which do not invalidate the product of this Thesis; however, it appears to be a limitation of the product.

Sequentially, we analyzed the statistical metrics of sensitivity, specificity, global accuracy and global error. The estimates obtained for these metrics showed that the model has relevant suitability for the intended use of mapping demographic information, efficiently performing the distribution of points in the cartography and the mapping of census information, when compared to the gold standard. The small distortions identified at this stage also appear to be limitations of the modeling, but they do not invalidate the modeling used to map the populated anthromes.
:::
